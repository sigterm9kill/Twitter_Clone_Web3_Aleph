"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _fs = _interopRequireDefault(require("fs"));

var _xFetch = _interopRequireDefault(require("@polkadot/x-fetch"));

var _ = require("./");

// Copyright 2017-2020 @polkadot/networks authors & contributors
// SPDX-License-Identifier: Apache-2.0
const ORIGINAL = 'https://raw.githubusercontent.com/paritytech/substrate/master/ss58-registry.json';
const OUTPUT = './.github/ss58-check.md';

function assertAndLog(check, error) {
  if (!check) {
    process.env.CI_LOG && _fs.default.appendFileSync(OUTPUT, `

${error}
`);
    throw new Error(error);
  }
}

describe('check latest Substrate ss58 registry', () => {
  let original;
  beforeAll(async () => {
    original = await (await (0, _xFetch.default)(ORIGINAL)).json();
  });
  it('has the same number as the original', () => {
    assertAndLog(_.all.length === original.registry.length, `Number of entries mismatched:: Expected ${original.registry.length} found ${_.all.length}`);
  });
  it('has no missing any entries', () => {
    const missing = original.registry.filter(({
      prefix
    }) => !_.all.some(n => n.prefix === prefix)).map(({
      displayName,
      prefix
    }) => `${displayName} (${prefix})`);
    assertAndLog(!missing.length, `Missing entries found: ${JSON.stringify(missing, null, 2)}`);
  });
  it('has no extra entries', () => {
    const missing = _.all.filter(({
      prefix
    }) => !original.registry.some(n => n.prefix === prefix)).map(({
      displayName,
      prefix
    }) => `${displayName} (${prefix})`);

    assertAndLog(!missing.length, `Extra entries found: ${JSON.stringify(missing, null, 2)}`);
  });
  it('has the same values as the original', () => {
    const fields = Object.keys(original.schema);
    const errors = original.registry.map(n => {
      const other = _.all.find(({
        prefix
      }) => prefix === n.prefix);

      return [`${n.displayName} (${n.prefix})`, other // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      ? fields.filter(f => JSON.stringify(n[f]) !== JSON.stringify(other[f])) : []];
    }).filter(([, fields]) => fields.length);
    assertAndLog(!errors.length, `Mismatches found: ${JSON.stringify(errors.map(([name, m]) => `${name}:: ${m.join(', ')}`), null, 2)}`);
  });
});